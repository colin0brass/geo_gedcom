from __future__ import annotations

from dataclasses import dataclass
import logging
from typing import Any, Dict, List, Optional, Protocol, Type

from geo_gedcom.app_hooks import AppHooks

from ..model import EnrichedPerson, Issue

logger = logging.getLogger(__name__)

# Rule Registry
_RULE_REGISTRY: Dict[str, Type['BaseRule']] = {}

def register_rule(cls: Type['BaseRule']) -> Type['BaseRule']:
    """
    Decorator to register a rule class in the global registry.
    
    Registers the rule by its rule_id attribute so it can be discovered
    and instantiated by the enrichment pipeline.
    
    Usage:
        @register_rule
        @dataclass
        class MyRule(BaseRule):
            rule_id: str = "my_rule"
            ...
    
    Args:
        cls: Rule class to register
        
    Returns:
        The same class (for use as a decorator)
    """
    if hasattr(cls, 'rule_id'):
        _RULE_REGISTRY[cls.rule_id] = cls
    return cls

def get_rule_registry() -> Dict[str, Type['BaseRule']]:
    """
    Get a copy of the global rule registry.
    
    Returns:
        Dictionary mapping rule_id to rule class
    """
    return _RULE_REGISTRY.copy()

@dataclass
class RuleStats:
    """
    Statistics about rule execution.
    
    Attributes:
        changed: Number of changes made by the rule
        issues: Number of issues generated by the rule
    """
    changed: int = 0
    issues: int = 0


class EnrichmentRule(Protocol):
    """
    Protocol defining the interface for enrichment rules.
    
    Rules analyze and enrich person data by:
    - Adding inferred events
    - Tightening date bounds
    - Adding issues for data quality concerns
    
    The apply method returns True if it made material changes, allowing
    the pipeline to iterate until convergence.
    
    Attributes:
        rule_id: Unique identifier for this rule
    """
    rule_id: str

    def apply(
        self,
        enriched_people: Dict[str, EnrichedPerson],
        original_people: Dict[str, Any],
        issues: List[Issue],
    ) -> bool:
        """
        Apply the rule to enrich person data.
        
        Args:
            enriched_people: Dictionary of person_id to EnrichedPerson
            original_people: Dictionary of person_id to original Person objects
            issues: List to append new issues to
            
        Returns:
            True if any changes were made, False otherwise
        """
        ...



class BaseRule:
    """
    Base class for enrichment rules.
    
    Provides common functionality including app hooks integration
    for progress reporting and stop requests.
    
    Attributes:
        rule_id: Unique identifier for this rule
        app_hooks: Optional application hooks for UI integration
    """
    rule_id: str = "base"
    app_hooks: Optional[AppHooks] = None

    def apply(self, enriched_people: Dict[str, EnrichedPerson], original_people: Dict[str, Any], issues: List[Issue], app_hooks: Optional[AppHooks] = None, rule_num: int = None, total_rules: int = None) -> bool:
        """
        Apply the rule to enrich person data.
        
        Must be implemented by subclasses.
        
        Args:
            enriched_people: Dictionary of person_id to EnrichedPerson
            original_people: Dictionary of person_id to original Person objects  
            issues: List to append new issues to
            app_hooks: Optional application hooks for progress reporting
            
        Returns:
            True if any changes were made, False otherwise
            
        Raises:
            NotImplementedError: Must be implemented by subclass
        """
        raise NotImplementedError
    
    def _report_step(self, info: str = "", target: Optional[int] = None, reset_counter: bool = False, plus_step: int = 0) -> None:
        """
        Report a step via app hooks if available. (Private method)

        Args:
            info (str): Information message.
            target (int): Target count for progress.
            reset_counter (bool): Whether to reset the counter.
            plus_step (int): Incremental step count.
        """
        if self.app_hooks and callable(getattr(self.app_hooks, "report_step", None)):
            self.app_hooks.report_step(info=info, target=target, reset_counter=reset_counter, plus_step=plus_step)
        else:
            logger.debug(info)

    def _stop_requested(self, logger_stop_message: str = "Stop requested by user") -> bool:
        """
        Check if stop has been requested via app hooks. (Private method)

        Returns:
            bool: True if stop requested, False otherwise.
        """
        if self.app_hooks and callable(getattr(self.app_hooks, "stop_requested", None)):
            if self.app_hooks.stop_requested():
                if logger_stop_message:
                    logger.debug(logger_stop_message)
                return True
        return False